## 大端小端扩展函数

### 1.is\_little

> 判断当前 CPU 是否是小端。
----------------------------

#### 原型

```js
is_little() => bool
```

#### 示例

```js
print(is_little());
```

### 2.htonl

> 将类型为 uint32_t 的整数，从主机字节顺序转成网络字节顺序。
----------------------------

#### 原型

```js
htonl(uint32_t) => uint32_t
```

#### 示例

```js
print(htonl(1));
```

### 3.ntohl

> 将类型为 uint32_t 的整数，从网络字节顺序转成主机字节顺序。
----------------------------

#### 原型

```js
ntohl(uint32_t) => uint32_t
```

#### 示例

```js
print(ntohl(2));
```

### 4.htons

> 将类型为 uint16_t 的整数，从主机字节顺序转成网络字节顺序。
----------------------------

#### 原型

```js
htons(uint16_t) => uint16_t
```

#### 示例

```js
print(htons(3));
```

### 5.ntohs

> 将类型为 uint16_t 的整数，从网络字节顺序转成主机字节顺序。
----------------------------

#### 原型

```js
ntohs(uint16_t) => uint16_t
```

#### 示例

```js
print(ntohs(4));
```

### 6.htonf

> 将类型为单精度的浮点数，从主机字节顺序转成网络字节顺序。
----------------------------

#### 原型

```js
htonf(float) => float
```

#### 示例

```js
print(htonf(5));
```

### 7.ntohf

> 将类型为单精度的浮点数，从网络字节顺序转成主机字节顺序。
----------------------------

#### 原型

```js
ntohf(float) => float
```

#### 示例

```js
print(ntohf(7));
```

### 8.htonll

> 将类型为 uint64_t 的整数，从主机字节顺序转成网络字节顺序。
----------------------------

#### 原型

```js
htonll(uint64_t) => uint64_t
```

#### 示例

```js
print(htonll(5));
```

### 9.ntohll

> 将类型为 uint64_t 的整数，从网络字节顺序转成主机字节顺序。
----------------------------

#### 原型

```js
ntohll(uint64_t) => uint64_t
```

#### 示例

```js
print(ntohll(1));
```

### 更多示例

```js
assert(is_little())
assert(htonl(0x11223344) == 0x44332211)
assert(ntohl(0x11223344) == 0x44332211)
assert(htons(0x1122) == 0x2211)
assert(ntohs(0x1122) == 0x2211)
assert(htonll(0x1122334455667788)==0x8877665544332211)
assert(ntohll(0x1122334455667788)==0x8877665544332211)
```
